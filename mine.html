<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<body>
<style>
td {
  width: 20px;
  height: 20px;
  border: 1px solid black;
}
</style>
<div id=boardc></div>
<pre id=log></pre>
<script>
let board = document.createElement('table');
document.getElementById('boardc').appendChild(board);

let cells = [];
let nRows = 10, nCols = 10;
let mines = new Set();
let startIx = undefined;
let counts = [];
let solved = [];

makeBoard();
loadMines();

updateBoard();

function updateBoard() {
  calculateCounts();
  let err;
  try {
    doSolve();
  } catch (ex) {
    err = ex;
  }
  redrawBoard();
  if (err) {
    log(err.message);
    throw err;
  }
}

function makeBoard() {
  for (let row = 0; row < nRows; row++) {
    let r = document.createElement('tr')
    board.appendChild(r)
    for (let col = 0; col < nCols; col++) {
      let c = document.createElement('td')
      r.appendChild(c)
      cells.push(c)

      let ix = row * nCols + col;
      c.onclick = (e) => {
        if (mines.has(ix)) {
          mines.delete(ix);
        } else {
          mines.add(ix);
        }
        saveMines();
        updateBoard();
      }
      c.oncontextmenu = (e) => {
        startIx = ix;
        saveMines();
        updateBoard();
        return false;
      }
    }
  }
}

function saveMines() {
  localStorage.mines = JSON.stringify(Array.from(mines))
  localStorage.size = JSON.stringify([nRows, nCols])
  localStorage.start = startIx
}
function loadMines() {
  if (localStorage.mines && localStorage.size) {
    mines = new Set(JSON.parse(localStorage.mines));
    [nRows, nCols] = JSON.parse(localStorage.size);
    startIx = localStorage.start ? parseInt(localStorage.start) : undefined;
  } else {
    mines = new Set();
    [nRows, nCols] = [10,10];
    startIx = undefined;
  }
}

function getNeighbors(ix) {
  if (typeof ix !== 'number') {
    throw new Error("expected number");
  }
  let col = ix % nCols;
  let row = (ix - col) / nCols;
  let res = [];
  [
    [-1,-1],
    [-1,0],
    [-1,1],
    [0,1],
    [1,1],
    [1,0],
    [1,-1],
    [0,-1],
  ].forEach(delta => {
    let newRow = row + delta[0];
    let newCol = col + delta[1];
    if (newRow !== -1 && newCol !== -1 && newRow !== nRows && newCol !== nCols) {
      res.push(newRow * nCols + newCol)
    }
  })
  return res;
}

function calculateCounts() {
  counts = [];
  for (ix = 0; ix < nRows * nCols; ix++) {
    let c;
    if (mines.has(ix)) {
      c = 'x'
    } else {
      c = 0
      for (let neighbor of getNeighbors(ix)) {
        if (mines.has(neighbor)) {
          c++;
        }
      }
    }
    counts.push(c);
  }
}

function redrawBoard() {
  for (let [i, cell] of cells.entries()) {
    if (counts[i] !== 0) {
      cell.textContent = counts[i]
    } else {
      cell.textContent = ''
    }
    if (i === startIx) {
      cell.textContent += 'o'
    }
    if (solved[i]) {
      if (solved[i] === 'x')  {
        cell.style.backgroundColor = 'red';
      } else {
        cell.style.backgroundColor = 'green';
      }
    } else {
      cell.style.backgroundColor = '';
    }
  }
}

function popSet(set) {
  let v = set[Symbol.iterator]().next().value;
  set.delete(v);
  return v;
}
function removeValue(array, value) {
  let i = array.indexOf(value);
  if (i === -1) {
    throw new Error("value not found");
  }
  array.splice(i, 1);
}

function doSolve() {
  solved = cells.map(() => undefined);

  let queueEmpty = [];
  let rulesPass1 = new Set();
  let rulesPass2 = new Set();
  let rulesByCell = solved.map(() => new Set());

  click(startIx);

  while (1) {
    if (queueEmpty.length) {
      for (let n of getNeighbors(queueEmpty.pop())) {
        if (solved[n]) {
          continue;
        }
        click(n);
      }
    } else if (rulesPass1.size) {
      let rule = popSet(rulesPass1);

      if (rule.max === 0) {
        rule.cells.forEach(n => click(n));
      } else if (rule.min === rule.cells.length) {
        rule.cells.forEach(n => flag(n));
      } else {
        rulesPass2.add(rule);
      }
    } else {
      return;
    }
  }

  function click(ix) {
    if (solved[ix]) {
      solved[ix] = 'x'
      throw new Error("already clicked")
    }
    if (counts[ix] === 'x') {
      solved[ix] = 'x';
      throw new Error("clicked mine")
    }

    solved[ix] = 'f';

    for (rule of rulesByCell[ix]) {
      removeValue(rule.cells, ix);
      rulesPass1.add(rule);
      rulesPass2.delete(rule);
    }

    if (counts[ix] === 0) {
      queueEmpty.push(ix);
      return;
    }

    let cells = [];
    let remaining = counts[ix];
    for (let n of getNeighbors(ix)) {
      if (solved[n] === 'm') {
        remaining--;
      } else if (!solved[n]) {
        cells.push(n);
      }
    }

    addRule({
      cells,
      min: remaining,
      max: remaining,
    });
  }

  function flag(ix) {
    if (solved[ix]) {
      solved[ix] = 'x'
      throw new Error("already clicked")
    }
    if (counts[ix] !== 'x') {
      solved[ix] = 'x'
      throw new Error("flagged non-mine")
    }

    solved[ix] = 'm'

    for (rule of rulesByCell[ix]) {
      removeValue(rule.cells, ix);
      if (rule.min === 0) {
        solved[ix] = 'x'
        throw new Error("rule has negative counts")
      }
      rule.min--;
      rule.max--;
      rulesPass1.add(rule);
      rulesPass2.delete(rule);
    }
  }

  function addRule(rule) {
    rulesPass1.add(rule);
    for (cell of rule.cells) {
      rulesByCell[cell].add(rule);
    }
  }
}

function log(str) {
  document.getElementById('log').textContent += str + '\n';
}

</script>
