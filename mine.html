<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<body>
<style>
td {
  width: 20px;
  height: 20px;
  border: 1px solid black;
}
</style>
<input type=checkbox id=playview onclick="redrawBoard()"> Player view
<div id=boardc></div>
<pre id=log></pre>
<script>
"use strict";
let board = document.createElement('table');
document.getElementById('boardc').appendChild(board);

let cells = [];
let nRows = 10, nCols = 10;
let mines = new Set();
let startIx = undefined;
let counts = [];
let solved = [];

makeBoard();
loadMines();

updateBoard();

function updateBoard() {
  calculateCounts();
  let err;
  try {
    doSolve();
  } catch (ex) {
    err = ex;
  }
  redrawBoard();
  if (err) {
    log(err.message);
    throw err;
  }
}

function makeBoard() {
  for (let row = 0; row < nRows; row++) {
    let r = document.createElement('tr')
    board.appendChild(r)
    for (let col = 0; col < nCols; col++) {
      let c = document.createElement('td')
      r.appendChild(c)
      cells.push(c)

      let ix = row * nCols + col;
      c.onclick = (e) => {
        if (mines.has(ix)) {
          mines.delete(ix);
        } else {
          mines.add(ix);
        }
        saveMines();
        updateBoard();
      }
      c.oncontextmenu = (e) => {
        startIx = ix;
        saveMines();
        updateBoard();
        return false;
      }
    }
  }
}

function saveMines() {
  localStorage.mines = JSON.stringify(Array.from(mines))
  localStorage.size = JSON.stringify([nRows, nCols])
  localStorage.start = startIx
}
function loadMines() {
  if (localStorage.mines && localStorage.size) {
    mines = new Set(JSON.parse(localStorage.mines));
    [nRows, nCols] = JSON.parse(localStorage.size);
    startIx = localStorage.start ? parseInt(localStorage.start) : undefined;
  } else {
    mines = new Set();
    [nRows, nCols] = [10,10];
    startIx = undefined;
  }
}

function getNeighbors(ix) {
  assert(typeof ix === 'number');
  let col = ix % nCols;
  let row = (ix - col) / nCols;
  let res = [];
  [
    [-1,-1],
    [-1,0],
    [-1,1],
    [0,1],
    [1,1],
    [1,0],
    [1,-1],
    [0,-1],
  ].forEach(delta => {
    let newRow = row + delta[0];
    let newCol = col + delta[1];
    if (newRow !== -1 && newCol !== -1 && newRow !== nRows && newCol !== nCols) {
      res.push(newRow * nCols + newCol)
    }
  })
  return res;
}

function calculateCounts() {
  counts = [];
  for (let ix = 0; ix < nRows * nCols; ix++) {
    let c;
    if (mines.has(ix)) {
      c = 'x'
    } else {
      c = 0
      for (let neighbor of getNeighbors(ix)) {
        if (mines.has(neighbor)) {
          c++;
        }
      }
    }
    counts.push(c);
  }
}

function redrawBoard() {
  let playview = document.getElementById('playview').checked
  for (let [i, cell] of cells.entries()) {
    if (counts[i] !== 0 && (!playview || solved[i])) {
      cell.textContent = counts[i]
    } else {
      cell.textContent = ''
    }
    if (i === startIx) {
      cell.textContent += 'o'
    }
    if (solved[i] && !playview) {
      cell.style.backgroundColor = 'green';
    } else {
      cell.style.backgroundColor = '';
    }
  }
}

function popSet(set) {
  let v = set[Symbol.iterator]().next().value;
  assert(v != undefined);
  set.delete(v);
  return v;
}
function removeValue(array, value) {
  let i = array.indexOf(value);
  assert(i !== -1);
  array.splice(i, 1);
}

function doSolve() {
  solved = cells.map(() => undefined);

  let queueEmpty = [];
  let rulesPass1 = new Set();
  let rulesPass2 = new Set();
  let rulesByCell = solved.map(() => new Set());

  if (counts[startIx] !== 'x') {
    click(startIx);
  }

  while (1) {
    if (queueEmpty.length) {
      for (let n of getNeighbors(queueEmpty.pop())) {
        if (solved[n]) {
          continue;
        }
        click(n);
      }
    } else if (rulesPass1.size) {
      let rule = popSet(rulesPass1);

      // We could do something faster than the slice here if we removed he exception from
      // removeValue
      if (rule.max === 0) {
        rule.cells.slice().forEach(n => click(n));
      } else if (rule.min === rule.cells.length) {
        rule.cells.slice().forEach(n => flag(n));
      } else {
        rulesPass2.add(rule);
      }
    } else if (rulesPass2.size) {
      let rule = popSet(rulesPass2);

      let otherRules = new Map();
      for (let cell of rule.cells) {
        for (let other of rulesByCell[cell]) {
          let count = otherRules.get(other) ?? 0;
          otherRules.set(other, count + 1);
        }
      }

      for (let [other, overlapCount] of otherRules) {

        if (rule.cells.length === overlapCount &&
            other.cells.length === overlapCount) {
          continue;
        }

        assert(rule.min <= (other.max + rule.cells.length - overlapCount));
        assert(other.min <= (rule.max + other.cells.length - overlapCount));

        function processOverlapping(rule1, rule2, overlapCount) {
          if (rule1.min === (rule2.max + rule1.cells.length - overlapCount)) {
            let rule1Cells = rule1.cells.slice();
            let rule2Cells = rule2.cells.slice();
            rule1Cells.forEach(n => {
              if (!rule2Cells.includes(n)) {
                flag(n);
              }
            })
            rule2Cells.forEach(n => {
              if (!rule1Cells.includes(n)) {
                click(n);
              }
            })
            assert(rule1.min === rule2.max);
            if (rule1.max !== rule1.min) {
              rule1.max = rule1.min;
              rulesPass1.add(rule1);
              rulesPass2.delete(rule1);
            }
            if (rule2.min !== rule2.max) {
              rule2.min = rule2.max;
              rulesPass1.add(rule2);
              rulesPass2.delete(rule2);
            }
            return true;
          }

          return false;
        }

        if (processOverlapping(rule, other, overlapCount) ||
            processOverlapping(other, rule, overlapCount)) {
          break;
        }
      }
    } else {
      return;
    }
  }

  function click(ix) {
    assert(!solved[ix]);
    assert(counts[ix] !== 'x');

    solved[ix] = 'f';

    for (let rule of rulesByCell[ix]) {
      removeValue(rule.cells, ix);
      rulesPass1.add(rule);
      rulesPass2.delete(rule);
    }

    if (counts[ix] === 0) {
      queueEmpty.push(ix);
      return;
    }

    let cells = [];
    let remaining = counts[ix];
    for (let n of getNeighbors(ix)) {
      if (solved[n] === 'm') {
        remaining--;
      } else if (!solved[n]) {
        cells.push(n);
      }
    }

    addRule({
      cells,
      min: remaining,
      max: remaining,
    });
  }

  function flag(ix) {
    assert(!solved[ix]);
    assert(counts[ix] === 'x');

    solved[ix] = 'm'

    for (let rule of rulesByCell[ix]) {
      removeValue(rule.cells, ix);
      assert(rule.min !== 0);
      rule.min--;
      rule.max--;
      rulesPass1.add(rule);
      rulesPass2.delete(rule);
    }
  }

  function addRule(rule) {
    rulesPass1.add(rule);
    for (let cell of rule.cells) {
      rulesByCell[cell].add(rule);
    }
  }
}

function log(str) {
  document.getElementById('log').textContent += str + '\n';
}

function assert(condition) {
  if (!condition) {
    throw new Error('failed assert')
  }
}

</script>
